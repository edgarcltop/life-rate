# Mahere Kaihanga / Roadmap Generator
# Copyright (C) 2022 Cheng Soon Goh
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.

from datetime import datetime
from dateutil.relativedelta import relativedelta
from painter import Painter
from print_dict import pd
import json
import calendar
from roadmapdict import RoadMapDict


class Mahere:
    # Private variables
    __VSPACER = 12
    __HSPACER = 2
    __DEFAULT_TITLE_TEXT_COLOUR = "Black"

    __DEFAULT_TIMELINE_FILL_COLOUR = "#006699"
    __DEFAULT_TIMELINE_TEXT_COLOUR = "White"

    __DEFAULT_GROUP_FILL_COLOUR = "#4dc3ff"
    __DEFAULT_GROUP_TEXT_COLOUR = "Black"

    __DEFAULT_TASK_FILL_COLOUR = "#b3e6ff"
    __DEFAULT_TASK_TEXT_COLOUR = "Black"

    __DEFAULT_MILESTONE_FILL_COLOUR = "Red"
    __DEFAULT_MILESTONE_TEXT_COLOUR = "Red"

    __DEFAULT_FOOTER_TEXT_COLOUR = "Black"

    # Constant variables
    VERSION = "0.1"
    WEEKLY = "W"
    MONTHLY = "M"
    QUARTERLY = "Q"
    HALF_YEARLY = "H"
    YEARLY = "Y"

    def __init__(self, width, height, output_file_name) -> None:
        self.__painter = Painter(width, height, output_file_name)
        self.__roadmap_dict = RoadMapDict()
        self.__width = width
        self.__task1_milestone_exists = False
        # self.__height = height
        # self.__output_file_name = output_file_name

        # Initialise settings
        self.text_font = ""
        self.background_colour = ""
        self.title_text = ""
        self.title_font = ""
        self.title_font_size = 0
        self.title_colour = ""
        self.show_footer = True
        self.footer_text = ""
        self.footer_font = ""
        self.footer_font_size = 0
        self.footer_colour = ""
        self.timeline_mode = ""
        self.timeline_item = 0
        self.timeline_fill_colour = ""
        self.timeline_text_colour = ""
        self.group_text_colour = ""
        self.task_text_colour = ""
        self.__roadmap_input = {}
        self.__today = datetime.today()

    def __repr__(self):
        return json.dumps(self.__roadmap_dict.roadmap_dict, indent=4)

    def __set_default_settings(self):
        """
        Set default settings
        """
        if self.text_font == "":
            self.text_font = "Arial"
        if self.background_colour == "":
            self.background_colour = "White"
        if self.title_text == "":
            self.title_text = "This is the default title"
        if self.title_font == "":
            self.text_font
        if self.title_font_size == 0:
            self.title_font_size = 18
        if self.title_colour == "":
            self.title_colour = self.__DEFAULT_TITLE_TEXT_COLOUR
        if self.footer_text == "":
            self.footer_text = f"Generated by Kaihanga Mahere v{self.VERSION}"
        if self.footer_font == "":
            self.footer_font = self.text_font
        if self.footer_font_size == 0:
            self.footer_font_size = 12
        if self.footer_colour == "":
            self.footer_colour = self.__DEFAULT_FOOTER_TEXT_COLOUR
        if self.timeline_mode == "":
            self.timeline_mode = self.MONTHLY
        if self.timeline_item == 0:
            self.timeline_item = 12
        if self.timeline_fill_colour == "":
            self.timeline_fill_colour = self.__DEFAULT_TIMELINE_FILL_COLOUR
        if self.timeline_text_colour == "":
            self.timeline_text_colour = self.__DEFAULT_TIMELINE_TEXT_COLOUR
        if self.group_text_colour == "":
            self.group_text_colour = self.__DEFAULT_GROUP_TEXT_COLOUR
        if self.task_text_colour == "":
            self.task_text_colour = self.__DEFAULT_TASK_TEXT_COLOUR

    def __generate_sample_data(self):
        if len(self.__roadmap_input) == 0:
            task_data = [
                {
                    "group": "Stream 1",
                    "colour": "green",
                    "tasks": [
                        {
                            "task": "Feature 1",
                            "start": datetime(2022, 10, 24),
                            "end": datetime(2022, 11, 24),
                            "colour": "lightgreen",
                            "milestones": [
                                {
                                    "milestone_text": "Milestone 1",
                                    "milestone_date": datetime(2022, 11, 24),
                                    "milestone_colour": "red",
                                }
                            ],
                        },
                        {
                            "task": "Feature 2",
                            "start": datetime(2022, 12, 24),
                            "end": datetime(2023, 4, 24),
                            "colour": "lightgreen",
                            "milestones": [
                                {
                                    "milestone_text": "Milestone 2",
                                    "milestone_date": datetime(2023, 2, 24),
                                    "milestone_colour": "red",
                                },
                                {
                                    "milestone_text": "Milestone 4",
                                    "milestone_date": datetime(2023, 4, 24),
                                    "milestone_colour": "red",
                                },
                            ],
                        },
                    ],
                },
                {
                    "group": "Stream 2",
                    "colour": "blue",
                    "tasks": [
                        {
                            "task": "Feature 3",
                            "start": datetime(2022, 4, 24),
                            "end": datetime(2022, 12, 24),
                            "colour": "lightblue",
                        },
                        {
                            "task": "Feature 4",
                            "start": datetime(2023, 1, 24),
                            "end": datetime(2024, 12, 24),
                            "colour": "lightblue",
                        },
                    ],
                },
                {
                    "group": "Stream 3",
                    "colour": "grey",
                    "tasks": [
                        {
                            "task": "Feature 5",
                            "start": datetime(2022, 10, 24),
                            "end": datetime(2023, 3, 24),
                            "colour": "lightgrey",
                        },
                        {
                            "task": "Feature 6",
                            "start": datetime(2023, 4, 24),
                            "end": datetime(2023, 7, 24),
                            "colour": "lightgrey",
                        },
                        {
                            "task": "Feature 7",
                            "start": datetime(2023, 8, 24),
                            "end": datetime(2023, 8, 24),
                            "colour": "lightgrey",
                        },
                    ],
                },
            ]
        else:
            task_data = self.__roadmap_input
        return task_data

    def __set_background(self):
        self.__painter.set_background_colour(self.background_colour)

    def __draw_title(self):
        self.__painter.set_font(
            self.title_font, self.title_font_size, self.title_colour
        )
        text_width, text_height = self.__painter.get_text_dimension(self.title_text)
        self.__painter.draw_text(
            (self.__width / 2) - text_width / 2, 30, self.title_text
        )
        self.__roadmap_dict.set_title_coordinates(
            (self.__width / 2) - text_width / 2,
            30,
            text_width,
            text_height,
            self.title_text,
        )

    def __draw_timeline(self, task_data):
        max_group_text_width = 0
        for x in task_data.keys():
            group_text = x
            self.__painter.set_font("Arial", 12, self.__roadmap_input[x].get("colour"))
            group_text_width, group_text_height = self.__painter.get_text_dimension(
                group_text
            )
            if group_text_width > max_group_text_width:
                max_group_text_width = group_text_width + 20

        # 40px is for right margin
        timeline_width = (
            self.__width
            - max_group_text_width
            - (self.__HSPACER * self.timeline_item)
            - 100
        )

        timeline_y_pos = 40
        timeline_height = 20

        timeline_item_width = timeline_width / self.timeline_item

        timeline_positions = []
        for x in range(self.timeline_item):
            timeline_x_pos = (
                (x * timeline_item_width)
                + max_group_text_width
                + (self.__HSPACER * x)
                + 50
            )

            # Draw timeline box
            self.__painter.set_colour(self.timeline_fill_colour)
            self.__painter.draw_box(
                timeline_x_pos, timeline_y_pos, timeline_item_width, timeline_height
            )
            self.__roadmap_dict.set_timeline_item_coordinates(
                x, timeline_x_pos, timeline_y_pos, timeline_item_width, timeline_height
            )

            # Draw timeline text
            timeline_text = ""
            if self.timeline_mode == self.WEEKLY:
                this_week = self.__today + relativedelta(weeks=+x)
                timeline_text = f"W{this_week.strftime('%W')} {this_week.year}"
                timeline_text_with_year = f"{this_week.year}{this_week.strftime('%W')}"

            if self.timeline_mode == self.MONTHLY:
                this_month = self.__today + relativedelta(months=+x)
                timeline_text = f"{this_month.strftime('%b')} {this_month.year}"
                timeline_text_with_year = (
                    f"{this_month.year}{this_month.strftime('%m')}"
                )

            if self.timeline_mode == self.QUARTERLY:
                this_month = self.__today + relativedelta(months=+(x * 3))
                this_quarter = (this_month.month - 1) // 3 + 1
                timeline_text = f"Q{this_quarter} {this_month.year}"
                timeline_text_with_year = f"{this_month.year}{this_quarter}"

            if self.timeline_mode == self.HALF_YEARLY:
                this_month = self.__today + relativedelta(months=+(x * 6))
                this_halfyear = (this_month.month - 1) // 6 + 1
                timeline_text = f"H{this_halfyear} {this_month.year}"
                timeline_text_with_year = f"{this_month.year}{this_halfyear}"

            if self.timeline_mode == self.YEARLY:
                this_month = self.__today + relativedelta(months=+(x * 12))
                timeline_text = f"{this_month.year}"
                timeline_text_with_year = f"{this_month.year}"

            self.__painter.set_font(self.text_font, 12, self.timeline_text_colour)
            x_pos, y_pos = self.__painter.get_display_text_position(
                timeline_x_pos,
                timeline_y_pos,
                timeline_item_width,
                timeline_height,
                timeline_text,
                "centre",
            )
            self.__painter.draw_text(x_pos, y_pos, timeline_text)
            self.__roadmap_dict.set_timeline_item_text(x, timeline_text)
            self.__roadmap_dict.set_timeline_item_value(x, timeline_text_with_year)

        return max_group_text_width, timeline_positions

    def __draw_footer(self):
        if self.show_footer:
            self.__painter.set_font(
                self.footer_font, self.footer_font_size, self.footer_colour
            )
            footer_width, footer_height = self.__painter.get_text_dimension(
                self.footer_text
            )
            footer_y_pos = self.__roadmap_dict.get_recommended_height() + 40
            self.__painter.draw_text(
                (self.__width / 2) - footer_width / 2,
                # self.__height - 10,
                footer_y_pos,
                self.footer_text,
            )
            self.__roadmap_dict.set_footer_coordinates(
                (self.__width / 2) - footer_width / 2,
                # self.__height - 10,
                footer_y_pos,
                footer_width,
                footer_height,
            )

    def __draw_group(self, x, y, max_width, group_text):
        additional_height_for_milestone = 6
        # Calculate number of milestones in group
        milestone_count = 0
        tasks = self.__roadmap_input[group_text].get("tasks", {})
        for task in tasks:
            for milestone in tasks[task].get("milestones", {}):
                if milestone != {}:
                    milestone_count += 1
                    break

        # Calc group height
        task_count = len(self.__roadmap_input[group_text].get("tasks"))
        group_total_height = (
            (20 * task_count)
            + (additional_height_for_milestone * milestone_count)
            + (2 * (task_count - 1))
        )
        group_total_width = max_width + 20

        self.__painter.set_colour(self.__roadmap_input[group_text].get("colour"))
        self.__painter.draw_box(x, y, group_total_width, group_total_height)

        self.__painter.set_colour(self.group_text_colour)
        x_pos, y_pos = self.__painter.get_display_text_position(
            x, y, group_total_width, group_total_height, group_text, "left"
        )
        self.__painter.draw_text(x_pos, y_pos, group_text)
        return y + group_total_height

    def __draw_groups(self, task_data, max_group_text_width, timeline_positions):
        if self.__task1_milestone_exists == True:
            group_y_start_pos = 80
        else:
            group_y_start_pos = 65

        next_group_y_pos = 0
        group_x_pos = 30
        group_y_pos = 0
        i = 0
        for group_item in task_data.keys():

            self.__painter.set_font(self.text_font, 12, self.timeline_text_colour)

            ## Determine group y (vertical) position
            if next_group_y_pos == 0:
                group_y_pos = group_y_start_pos
            else:
                group_y_pos = next_group_y_pos + 10  # Gap between groups

            next_group_y_pos = self.__draw_group(
                group_x_pos, group_y_pos, max_group_text_width, group_item
            )
            # next_group_y_pos += 5
            # next_group_y_pos = group_y_pos

            ## Set Task
            task_y_pos = group_y_pos
            # next_group_y_pos = task_y_pos

            j = 0
            for task in self.__roadmap_input[group_item].get("tasks"):
                task_text = task
                ## Determine task y (vertical) position
                _, text_height = self.__painter.get_text_dimension(task_text)
                next_task_y_pos = task_y_pos + text_height * j + (self.__VSPACER * j)
                # next_group_y_pos = next_task_y_pos
                text_height = 20

                # Draw task bar
                bar_start_x_pos = 0
                total_bar_width = 0
                row_match = 0

                (task_start_period, task_end_period) = self.__get_task_period(
                    group_item, task
                )

                milestones = self.__get_milestones(group_item, task)

                for timeline_index in range(self.timeline_item):
                    this_period = self.__get_timeline_period(timeline_index)

                    if (
                        task_start_period <= this_period
                        and task_end_period >= this_period
                    ):
                        (
                            task_box_x_pos,
                            task_box_y_pos,
                            task_box_width,
                            task_box_height,
                        ) = self.__roadmap_dict.get_timeline_item_coordinates(
                            timeline_index
                        )
                        if bar_start_x_pos == 0:
                            bar_start_x_pos = task_box_x_pos

                        row_match += 1

                if row_match > 0:
                    task_box_y_pos = next_task_y_pos
                    task_box_height = text_height
                    total_bar_width = task_box_width * row_match + (
                        self.__HSPACER * row_match - 1
                    )

                    self.__painter.set_colour(
                        self.__roadmap_input[group_item]
                        .get("tasks")[task]
                        .get("colour")
                    )
                    self.__painter.draw_box(
                        bar_start_x_pos,
                        task_box_y_pos,
                        total_bar_width,
                        task_box_height,
                    )

                    self.__roadmap_dict.set_groups_item_task_coordinates(
                        i,
                        j,
                        bar_start_x_pos,
                        task_box_y_pos,
                        total_bar_width,
                        task_box_height,
                        task_text,
                    )

                    self.__painter.set_font(self.text_font, 12, self.task_text_colour)
                    text_x_pos, text_y_pos = self.__painter.get_display_text_position(
                        bar_start_x_pos,
                        task_box_y_pos,
                        total_bar_width,
                        text_height,
                        task_text,
                        "centre",
                    )
                    self.__painter.draw_text(text_x_pos, text_y_pos, f"{task_text}")

                # Loop one more time to draw milestones
                bar_start_x_pos = 0
                total_bar_width = 0
                milestones = self.__get_milestones(group_item, task)
                print(f"{task} - milestones: {milestones}")
                for timeline_index in range(self.timeline_item):
                    this_period = self.__get_timeline_period(timeline_index)

                    if (
                        task_start_period <= this_period
                        and task_end_period >= this_period
                    ):
                        (
                            task_box_x_pos,
                            task_box_y_pos,
                            task_box_width,
                            task_box_height,
                        ) = self.__roadmap_dict.get_timeline_item_coordinates(
                            timeline_index
                        )
                        # if bar_start_x_pos == 0:
                        bar_start_x_pos = task_box_x_pos

                        ## Milestone loop
                        for milestone_text in milestones:
                            milestone_date = milestones[milestone_text].get("date")
                            # Determine timeline item x position
                            (
                                _,
                                _,
                                timeline_item_width,
                                _,
                            ) = self.__roadmap_dict.get_timeline_item_coordinates(
                                timeline_index
                            )

                            (
                                correct_timeline,
                                pos_percentage,
                            ) = self.__get_timeline_pos_percentage(
                                timeline_index, milestone_date
                            )
                            if correct_timeline == True:
                                # Draw milestone diamond
                                self.__painter.draw_diamond(
                                    bar_start_x_pos
                                    + (timeline_item_width * pos_percentage)
                                    - 8
                                    - 3,
                                    next_task_y_pos - 3,
                                    26,
                                    26,
                                )

                                self.__painter.set_font(
                                    self.text_font,
                                    10,
                                    self.__DEFAULT_MILESTONE_TEXT_COLOUR,
                                )
                                width, _ = self.__painter.get_text_dimension(
                                    milestone_text
                                )
                                # Draw milestone text
                                self.__painter.draw_text(
                                    bar_start_x_pos
                                    + (timeline_item_width * pos_percentage)
                                    - (width / 3),
                                    next_task_y_pos - 6,
                                    milestone_text,
                                )
                j += 1
            i += 1

    def __get_timeline_pos_percentage(self, timeline_index, milestone_date):
        correct_timeline = False
        pos_percentage = 0
        this_period = self.__get_timeline_period(timeline_index)

        if self.timeline_mode == self.WEEKLY:
            pos_percentage = milestone_date.weekday() / 7
            milestone_period = f"{milestone_date.year}{milestone_date.strftime('%W')}"
            print(f"milestone_period: {milestone_period}, this_period: {this_period}")
            if milestone_period == this_period:
                correct_timeline = True

        if self.timeline_mode == self.MONTHLY:
            _, last_day = calendar.monthrange(this_period.year, this_period.month)
            pos_percentage = milestone_date.day / last_day
            if (milestone_date.year == this_period.year) and (
                milestone_date.month == this_period.month
            ):
                correct_timeline = True

        if self.timeline_mode == self.QUARTERLY:
            pos_percentage = 1  # milestone_date.month // 3 + 1
            milestone_period = (
                f"{milestone_date.year}{self.__get_quarter_from_date(milestone_date)}"
            )
            print(
                f"milestone date: {milestone_date}, milestone_period: {milestone_period}, this_period: {this_period}"
            )
            if milestone_period == this_period:
                print(">>Matched")
                correct_timeline = True

        return (correct_timeline, pos_percentage)

    def __get_timeline_period(self, timeline_index):
        if self.timeline_mode == self.WEEKLY:
            this_period = self.__roadmap_dict.get_timeline_item_value(timeline_index)

        if self.timeline_mode == self.MONTHLY:
            this_month = (self.__today + relativedelta(months=+timeline_index)).month
            this_year = (self.__today + relativedelta(months=+timeline_index)).year
            this_period = datetime(this_year, this_month, 1)

        if self.timeline_mode == self.QUARTERLY:
            this_period = self.__roadmap_dict.get_timeline_item_value(timeline_index)

        if self.timeline_mode == self.HALF_YEARLY:
            this_period = self.__roadmap_dict.get_timeline_item_value(timeline_index)

        if self.timeline_mode == self.YEARLY:
            this_period = self.__roadmap_dict.get_timeline_item_value(timeline_index)

        return this_period

    def __get_task_period(self, group, task):
        if self.timeline_mode == self.WEEKLY:
            (
                task_start_period,
                task_end_period,
            ) = self.__get_weekly_dates(group, task)

        if self.timeline_mode == self.MONTHLY:
            (
                task_start_period,
                task_end_period,
            ) = self.__get_monthly_dates(group, task)

        if self.timeline_mode == self.QUARTERLY:
            (
                task_start_period,
                task_end_period,
            ) = self.__get_quarterly_dates(group, task)

        if self.timeline_mode == self.HALF_YEARLY:
            (
                task_start_period,
                task_end_period,
            ) = self.__get_half_yearly_dates(group, task)

        if self.timeline_mode == self.YEARLY:
            (
                task_start_period,
                task_end_period,
            ) = self.__get_yearly_dates(group, task)

        return task_start_period, task_end_period

    def __get_yearly_dates(self, group, task):
        task_start_date = datetime(
            task.get("start").year,
            task.get("start").month,
            task.get("start").day,
        )
        task_end_date = datetime(
            task.get("end").year,
            task.get("end").month,
            task.get("end").day,
        )
        task_start_period = f"{task_start_date.year}"
        task_end_period = f"{task_end_date.year}"

        return task_start_period, task_end_period

    def __get_half_yearly_dates(self, group, task):
        task_start_date = datetime(
            task.get("start").year,
            task.get("start").month,
            task.get("start").day,
        )
        task_end_date = datetime(
            task.get("end").year,
            task.get("end").month,
            task.get("end").day,
        )
        task_start_period = f"{task_start_date.year}{task_start_date.month // 6 + 1}"
        task_end_period = f"{task_end_date.year}{task_end_date.month // 6 + 1}"

        return task_start_period, task_end_period

    def __get_quarter_from_date(self, date):
        return (date.month - 1) // 3 + 1

    def __get_quarterly_dates(self, group, task):
        task_start_date = datetime(
            self.__roadmap_input[group].get("tasks")[task].get("start").year,
            self.__roadmap_input[group].get("tasks")[task].get("start").month,
            self.__roadmap_input[group].get("tasks")[task].get("start").day,
        )
        task_end_date = datetime(
            self.__roadmap_input[group].get("tasks")[task].get("end").year,
            self.__roadmap_input[group].get("tasks")[task].get("end").month,
            self.__roadmap_input[group].get("tasks")[task].get("end").day,
        )
        task_start_period = (
            f"{task_start_date.year}{self.__get_quarter_from_date(task_start_date)}"
        )
        task_end_period = (
            f"{task_end_date.year}{self.__get_quarter_from_date(task_start_date)}"
        )

        return task_start_period, task_end_period

    def __get_monthly_dates(self, group, task):
        task_start_period = datetime(
            self.__roadmap_input[group].get("tasks")[task].get("start").year,
            self.__roadmap_input[group].get("tasks")[task].get("start").month,
            1,
        )
        task_end_period = datetime(
            self.__roadmap_input[group].get("tasks")[task].get("end").year,
            self.__roadmap_input[group].get("tasks")[task].get("end").month,
            1,
        )
        # return task_start_period, task_end_period, milestone_dates, this_period
        return task_start_period, task_end_period

    def __get_milestones(self, group, task):
        return self.__roadmap_input[group].get("tasks", {})[task].get("milestones", {})

    def __get_weekly_dates(self, group, task):
        task_start_date = datetime(
            self.__roadmap_input[group].get("tasks")[task].get("start").year,
            self.__roadmap_input[group].get("tasks")[task].get("start").month,
            self.__roadmap_input[group].get("tasks")[task].get("start").day,
        )
        task_end_date = datetime(
            self.__roadmap_input[group].get("tasks")[task].get("end").year,
            self.__roadmap_input[group].get("tasks")[task].get("end").month,
            self.__roadmap_input[group].get("tasks")[task].get("end").day,
        )
        task_start_period = f"{task_start_date.year}{task_start_date.strftime('%W')}"
        task_end_period = f"{task_end_date.year}{task_end_date.strftime('%W')}"

        return task_start_period, task_end_period

    def add_group(self, group_text, colour=None) -> str:
        tasks = {}
        if colour is None:
            colour = self.__DEFAULT_GROUP_FILL_COLOUR
        group = {"group": group_text, "colour": colour, "tasks": tasks}
        self.__roadmap_input[group_text] = {"colour": colour, "tasks": {}}
        return group_text

    def add_task(
        self, group_text, task_text, start_date, end_date, colour=None
    ) -> None:
        # Expecting YYYY-MM-DD format. E.g 2022-08-29
        start_date_object = datetime.strptime(start_date, "%Y-%m-%d")
        end_date_object = datetime.strptime(end_date, "%Y-%m-%d")

        if colour is None:
            colour = self.__DEFAULT_TASK_FILL_COLOUR
        task = {
            "start": start_date_object,
            "end": end_date_object,
            "colour": colour,
            "milestones": {},
        }

        self.__roadmap_input[group_text]["tasks"][task_text] = task

        # for group in self.__roadmap_input:
        #     if group.get("group") == group_text:
        #         group.get("tasks").append(task)

        return task_text

    def add_milestone(
        self, group_text, task_text, milestone_text, milestone_date, colour=None
    ):
        # Expecting YYYY-MM-DD format. E.g 2022-08-29
        milestone_date_object = datetime.strptime(milestone_date, "%Y-%m-%d")
        if colour is None:
            colour = self.__DEFAULT_MILESTONE_FILL_COLOUR

        group1 = next((iter(self.__roadmap_input.values())))
        task1 = next(iter(group1["tasks"].values()))
        # print("Task 1 :", task1)
        # print("Milestones :", task1["milestones"])
        if task1["milestones"] == {}:
            self.__task1_milestone_exists = False
        else:
            self.__task1_milestone_exists = True

        milestone = {
            "date": milestone_date_object,
            "colour": colour,
        }
        self.__roadmap_input[group_text]["tasks"][task_text]["milestones"][
            milestone_text
        ] = milestone
        return milestone_text

    def render(self) -> None:
        # Default settings
        self.__set_default_settings()

        # Create a sample data structure if none is provided
        roadmap_input = self.__generate_sample_data()

        # Set backgroud
        self.__set_background()

        # Set Title
        self.__draw_title()

        # Draw Timeline
        max_group_text_width, timeline_positions = self.__draw_timeline(roadmap_input)

        # Draw Group
        self.__draw_groups(roadmap_input, max_group_text_width, timeline_positions)

        # Draw footer
        self.__draw_footer()
        # pd(self.__roadmap_dict.roadmap_dict)
        # with open("output.json", "w") as write_file:
        #     json.dump(self.__roadmap_dict.roadmap_dict, write_file, indent=4)

        # pd(self.__roadmap_input)

        # Save
        self.__painter.save_surface()

        return self.__roadmap_dict.get_recommended_height()
